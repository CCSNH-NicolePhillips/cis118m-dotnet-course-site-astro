---
interface Props {
  code: string;
  starterId: string;
  height?: number;
  instructions?: string;
  showFullEditorLink?: boolean;
  validationRegex?: string;
}

const { 
  code, 
  starterId, 
  height = 200,
  instructions,
  showFullEditorLink = true,
  validationRegex
} = Astro.props;

const runnerId = `runner-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="try-it-now-runner" data-runner-id={runnerId} data-validation-regex={validationRegex}>
  {instructions && (
    <div class="instructions">
      <span class="icon">▶️</span>
      <span>{instructions}</span>
    </div>
  )}
  
  <div class="editor-container">
    <div class="editor-wrapper" style={`height: ${height}px`}>
      <div id={`editor-${runnerId}`} class="monaco-editor-container"></div>
    </div>
    
    <div class="toolbar" id="lab-toolbar">
      <button class="btn btn-run" id="lab-run-button" data-action="run">
        <span class="icon">▶</span>
        Run
      </button>
      <button class="btn btn-reset" id="lab-reset-button" data-action="reset">
        <span class="icon">↺</span>
        Reset
      </button>
      {showFullEditorLink && (
        <a href={`/editor/?week=01&starter=${starterId}`} class="link-full-editor" target="_blank">
          Open in full editor ↗
        </a>
      )}
    </div>
  </div>
  
  <div class="output-container" id="lab-output" data-collapsed="true">
    <div class="output-header" data-action="toggle-output">
      <span class="icon">▼</span>
      <span class="title">Output</span>
      <span class="status"></span>
    </div>
    <div class="output-content">
      <div class="output-tabs">
        <button class="output-tab active" data-tab="console">Console</button>
        <button class="output-tab" data-tab="errors">Errors</button>
      </div>
      <div class="output-panel" data-panel="console">
        <pre class="output-text"></pre>
      </div>
      <div class="output-panel hidden" data-panel="errors">
        <pre class="error-text"></pre>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ runnerId, code, starterId }}>
  (async () => {
    const container = document.querySelector(`[data-runner-id="${runnerId}"]`);
    if (!container) return;
    
    const editorDiv = container.querySelector(`#editor-${runnerId}`);
    const runBtn = container.querySelector('[data-action="run"]');
    const resetBtn = container.querySelector('[data-action="reset"]');
    const outputContainer = container.querySelector('.output-container');
    const outputHeader = container.querySelector('[data-action="toggle-output"]');
    const statusSpan = container.querySelector('.status');
    const consoleOutput = container.querySelector('[data-panel="console"] .output-text');
    const errorOutput = container.querySelector('[data-panel="errors"] .error-text');
    const outputTabs = container.querySelectorAll('.output-tab');
    const outputPanels = container.querySelectorAll('.output-panel');
    
    let editor = null;
    const originalCode = code;
    
    // Wait for Monaco to load
    const waitForMonaco = async () => {
      let attempts = 0;
      while (!window.monaco) {
        if (attempts++ > 50) throw new Error('Monaco failed to load');
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    };
    
    try {
      await waitForMonaco();
      
      // Register C# completion provider (once per page)
      if (!window.__csharpCompletionRegistered) {
        window.__csharpCompletionRegistered = true;
        monaco.languages.registerCompletionItemProvider('csharp', {
          triggerCharacters: ['.', ' '],
          provideCompletionItems: (model, position) => {
            const word = model.getWordUntilPosition(position);
            const range = {
              startLineNumber: position.lineNumber,
              endLineNumber: position.lineNumber,
              startColumn: word.startColumn,
              endColumn: word.endColumn
            };
            
            // Get the text before cursor to determine context
            const lineContent = model.getLineContent(position.lineNumber);
            const textBefore = lineContent.substring(0, position.column - 1);
            
            const suggestions = [];
            
            // Console methods (after "Console.")
            if (textBefore.endsWith('Console.')) {
              suggestions.push(
                { label: 'WriteLine', kind: monaco.languages.CompletionItemKind.Method, insertText: 'WriteLine($0);', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'void Console.WriteLine(string value)', documentation: 'Writes a line to the console output.', range },
                { label: 'Write', kind: monaco.languages.CompletionItemKind.Method, insertText: 'Write($0);', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'void Console.Write(string value)', documentation: 'Writes to the console without a newline.', range },
                { label: 'ReadLine', kind: monaco.languages.CompletionItemKind.Method, insertText: 'ReadLine()', detail: 'string Console.ReadLine()', documentation: 'Reads a line of input from the console.', range },
                { label: 'ReadKey', kind: monaco.languages.CompletionItemKind.Method, insertText: 'ReadKey()', detail: 'ConsoleKeyInfo Console.ReadKey()', documentation: 'Reads a single key press from the console.', range },
                { label: 'Clear', kind: monaco.languages.CompletionItemKind.Method, insertText: 'Clear()', detail: 'void Console.Clear()', documentation: 'Clears the console screen.', range },
              );
            }
            // String methods (after string variable with dot)
            else if (textBefore.match(/"\s*\.\s*$/) || textBefore.match(/[a-zA-Z_]\w*\.\s*$/)) {
              suggestions.push(
                { label: 'ToUpper', kind: monaco.languages.CompletionItemKind.Method, insertText: 'ToUpper()', detail: 'string ToUpper()', documentation: 'Converts string to uppercase.', range },
                { label: 'ToLower', kind: monaco.languages.CompletionItemKind.Method, insertText: 'ToLower()', detail: 'string ToLower()', documentation: 'Converts string to lowercase.', range },
                { label: 'Trim', kind: monaco.languages.CompletionItemKind.Method, insertText: 'Trim()', detail: 'string Trim()', documentation: 'Removes whitespace from both ends.', range },
                { label: 'Length', kind: monaco.languages.CompletionItemKind.Property, insertText: 'Length', detail: 'int Length', documentation: 'Gets the number of characters.', range },
                { label: 'Contains', kind: monaco.languages.CompletionItemKind.Method, insertText: 'Contains($0)', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'bool Contains(string value)', documentation: 'Returns true if string contains the value.', range },
                { label: 'Replace', kind: monaco.languages.CompletionItemKind.Method, insertText: 'Replace($0)', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'string Replace(string old, string new)', documentation: 'Replaces occurrences of a string.', range },
                { label: 'Split', kind: monaco.languages.CompletionItemKind.Method, insertText: 'Split($0)', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'string[] Split(char separator)', documentation: 'Splits string into an array.', range },
                { label: 'Substring', kind: monaco.languages.CompletionItemKind.Method, insertText: 'Substring($0)', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'string Substring(int start, int length)', documentation: 'Gets a portion of the string.', range },
              );
            }
            // General keywords and common items
            else {
              suggestions.push(
                { label: 'Console', kind: monaco.languages.CompletionItemKind.Class, insertText: 'Console', detail: 'System.Console', documentation: 'Provides methods for console I/O.', range },
                { label: 'Console.WriteLine', kind: monaco.languages.CompletionItemKind.Snippet, insertText: 'Console.WriteLine($0);', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'Print a line to console', documentation: 'Writes a line to the console output.', range },
                { label: 'Console.ReadLine', kind: monaco.languages.CompletionItemKind.Snippet, insertText: 'Console.ReadLine()', detail: 'Read a line from console', documentation: 'Reads a line of input from the console.', range },
                { label: 'string', kind: monaco.languages.CompletionItemKind.Keyword, insertText: 'string', detail: 'keyword', documentation: 'Represents text as a sequence of characters.', range },
                { label: 'int', kind: monaco.languages.CompletionItemKind.Keyword, insertText: 'int', detail: 'keyword', documentation: 'Represents a 32-bit signed integer.', range },
                { label: 'double', kind: monaco.languages.CompletionItemKind.Keyword, insertText: 'double', detail: 'keyword', documentation: 'Represents a double-precision floating-point number.', range },
                { label: 'bool', kind: monaco.languages.CompletionItemKind.Keyword, insertText: 'bool', detail: 'keyword', documentation: 'Represents a Boolean value (true/false).', range },
                { label: 'var', kind: monaco.languages.CompletionItemKind.Keyword, insertText: 'var', detail: 'keyword', documentation: 'Implicitly typed local variable.', range },
                { label: 'if', kind: monaco.languages.CompletionItemKind.Snippet, insertText: 'if (${1:condition})\\n{\\n\\t$0\\n}', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'if statement', range },
                { label: 'for', kind: monaco.languages.CompletionItemKind.Snippet, insertText: 'for (int ${1:i} = 0; ${1:i} < ${2:length}; ${1:i}++)\\n{\\n\\t$0\\n}', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'for loop', range },
                { label: 'foreach', kind: monaco.languages.CompletionItemKind.Snippet, insertText: 'foreach (var ${1:item} in ${2:collection})\\n{\\n\\t$0\\n}', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'foreach loop', range },
                { label: 'while', kind: monaco.languages.CompletionItemKind.Snippet, insertText: 'while (${1:condition})\\n{\\n\\t$0\\n}', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, detail: 'while loop', range },
              );
            }
            
            return { suggestions };
          }
        });
      }
      
      // Initialize Monaco editor - always use vs-dark for consistent styling
      editor = monaco.editor.create(editorDiv, {
        value: originalCode,
        language: 'csharp',
        theme: 'vs-dark',
        minimap: { enabled: false },
        fontSize: 14,
        lineNumbers: 'on',
        scrollBeyondLastLine: false,
        automaticLayout: true,
        tabSize: 4,
        quickSuggestions: {
          other: true,
          comments: false,
          strings: true,
        },
        suggestOnTriggerCharacters: true,
        parameterHints: { enabled: true },
        autoClosingBrackets: 'always',
        autoClosingQuotes: 'always',
        autoIndent: 'full',
        renderLineHighlight: 'all',
      });
      
      // Theme sync removed - always use vs-dark for code snippets
      
    } catch (err) {
      console.error('[TryItNowRunner] Monaco init failed:', err);
      editorDiv.innerHTML = `<textarea style="width:100%;height:100%;font-family:monospace;padding:8px;">${originalCode}</textarea>`;
    }
    
    // Expand/collapse output
    function toggleOutput(forceExpand = false) {
      const isCollapsed = outputContainer.dataset.collapsed === 'true';
      if (forceExpand || isCollapsed) {
        outputContainer.dataset.collapsed = 'false';
        outputHeader.querySelector('.icon').textContent = '▲';
        // Scroll into view
        setTimeout(() => {
          outputContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100);
      } else {
        outputContainer.dataset.collapsed = 'true';
        outputHeader.querySelector('.icon').textContent = '▼';
      }
    }
    
    outputHeader.addEventListener('click', () => toggleOutput());
    
    // Output tab switching
    outputTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const targetPanel = tab.dataset.tab;
        outputTabs.forEach(t => t.classList.toggle('active', t === tab));
        outputPanels.forEach(p => {
          p.classList.toggle('hidden', p.dataset.panel !== targetPanel);
        });
      });
    });
    
    // Run code
    async function runCode() {
      const currentCode = editor ? editor.getValue() : editorDiv.querySelector('textarea')?.value || originalCode;
      
      console.log(`[TryItNowRunner ${runnerId}] Running code for starterId: ${starterId}`);
      console.log(`[TryItNowRunner ${runnerId}] Code preview:`, currentCode.substring(0, 100));
      console.log(`[TryItNowRunner ${runnerId}] Output elements:`, { 
        consoleOutput: consoleOutput?.tagName,
        errorOutput: errorOutput?.tagName,
        statusSpan: statusSpan?.tagName
      });
      
      runBtn.disabled = true;
      runBtn.innerHTML = '<span class="icon">⏳</span> Running...';
      statusSpan.textContent = '⏳ Running...';
      
      // Expand output and clear
      toggleOutput(true);
      consoleOutput.textContent = '(running...)';
      errorOutput.textContent = '';
      
      try {
        const response = await fetch('/api/compile-and-run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            code: currentCode,
            starterId: starterId,
          }),
        });
        
        console.log(`[TryItNowRunner ${runnerId}] Response status:`, response.status);
        
        if (!response.ok) {
          const errorBody = await response.text();
          console.error(`[TryItNowRunner ${runnerId}] Error response body:`, errorBody);
          throw new Error(`HTTP ${response.status}: ${errorBody}`);
        }
        
        const result = await response.json();
        console.log(`[TryItNowRunner ${runnerId}] Result:`, result);
        
        // Check validation regex
        let isValidated = false;
        const validationRegexStr = container.getAttribute('data-validation-regex');
        if (result.stdout && validationRegexStr) {
          const regexParts = validationRegexStr.match(/\/(.*)\/(.*)/);  
          if (regexParts) {
            const regex = new RegExp(regexParts[1], regexParts[2]);
            if (regex.test(result.stdout)) {
              isValidated = true;
              statusSpan.innerHTML = '<span style="color: #4ec9b0; font-weight: bold;">✅ Requirements Met</span>';
            }
          }
        }
        
        // Display output
        consoleOutput.textContent = result.stdout || '(no output)';
        
        // Display errors
        const hasErrors = result.stderr || (result.diagnostics && result.diagnostics.some(d => d.severity === 'Error'));
        if (hasErrors) {
          let errorText = '';
          if (result.stderr) {
            errorText += result.stderr + '\n\n';
          }
          if (result.diagnostics) {
            result.diagnostics.forEach(d => {
              if (d.severity === 'Error') {
                errorText += `Line ${d.line}: ${d.message}\n`;
              }
            });
          }
          errorOutput.textContent = errorText;
          statusSpan.textContent = '⚠️ Completed with errors';
          statusSpan.style.color = '#ef4444';
          
          // Auto-switch to errors tab
          outputTabs.forEach(t => t.classList.toggle('active', t.dataset.tab === 'errors'));
          outputPanels.forEach(p => p.classList.toggle('hidden', p.dataset.panel !== 'errors'));
        } else {
          // Only set generic success if validation hasn't already passed
          if (!isValidated) {
            statusSpan.textContent = '✓ Execution Successful';
            statusSpan.style.color = '#10b981';
          }
          
          // Participation Heartbeat (optional - only if logged in)
          try {
            if (window.__auth && typeof window.__auth.getAccessToken === 'function') {
              const token = await window.__auth.getAccessToken().catch(() => null);
              if (token) {
                await fetch('/api/progress-update', {
                  method: 'POST',
                  headers: { 
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json' 
                  },
                  body: JSON.stringify({
                    slug: window.location.pathname,
                    activityId: runnerId,
                    status: 'completed'
                  }),
                }).catch(() => {}); // Ignore progress update failures
              }
            }
          } catch (heartbeatErr) {
            // Silently ignore - participation tracking is optional
          }
        }
        
      } catch (err) {
        console.error('[TryItNowRunner] Run failed:', err);
        errorOutput.textContent = `Failed to run code: ${err.message}`;
        statusSpan.textContent = '✗ Error';
        statusSpan.style.color = '#ef4444';
      } finally {
        runBtn.disabled = false;
        runBtn.innerHTML = '<span class="icon">▶</span> Run';
      }
    }
    
    // Reset code
    function resetCode() {
      if (editor) {
        editor.setValue(originalCode);
      } else {
        const textarea = editorDiv.querySelector('textarea');
        if (textarea) textarea.value = originalCode;
      }
      consoleOutput.textContent = '';
      errorOutput.textContent = '';
      statusSpan.textContent = '';
      outputContainer.dataset.collapsed = 'true';
      outputHeader.querySelector('.icon').textContent = '▼';
    }
    
    runBtn.addEventListener('click', runCode);
    resetBtn.addEventListener('click', resetCode);
    
    // Keyboard shortcut: Ctrl+Enter to run
    if (editor) {
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, runCode);
    }
    
  })();
</script>

<style>
  .try-it-now-runner {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    margin: 20px 0;
  }
  
  .instructions {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    background: var(--accent);
    color: white;
    font-weight: 500;
    font-size: 14px;
  }
  
  .instructions .icon {
    font-size: 16px;
  }
  
  .editor-container {
    border-bottom: 1px solid var(--border);
  }
  
  .editor-wrapper {
    border-bottom: 1px solid var(--border);
  }
  
  .monaco-editor-container {
    height: 100%;
    width: 100%;
  }
  
  .toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    background: var(--panel2);
  }
  
  .btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 14px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .btn:hover:not(:disabled) {
    background: var(--accent-hover);
  }
  
  .btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  .btn-reset {
    background: var(--panel);
    color: var(--text);
    border: 1px solid var(--border);
  }
  
  .btn-reset:hover:not(:disabled) {
    background: var(--navitem-hover);
  }
  
  .link-full-editor {
    margin-left: auto;
    font-size: 13px;
    color: var(--text-muted);
    text-decoration: none;
    transition: color 0.2s;
  }
  
  .link-full-editor:hover {
    color: var(--accent);
    text-decoration: underline;
  }
  
  .output-container {
    border-top: 1px solid var(--border);
  }
  
  .output-container[data-collapsed="true"] .output-content {
    display: none;
  }
  
  .output-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    background: var(--panel2);
    cursor: pointer;
    user-select: none;
    transition: background 0.2s;
  }
  
  .output-header:hover {
    background: var(--navitem-hover);
  }
  
  .output-header .icon {
    font-size: 12px;
    transition: transform 0.2s;
  }
  
  .output-header .title {
    font-weight: 600;
    color: var(--text);
    font-size: 14px;
  }
  
  .output-header .status {
    margin-left: auto;
    font-size: 13px;
    font-weight: 500;
  }
  
  .output-tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    background: var(--panel2);
  }
  
  .output-tab {
    padding: 8px 16px;
    background: transparent;
    border: none;
    border-bottom: 2px solid transparent;
    color: var(--text-muted);
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .output-tab:hover {
    color: var(--text);
    background: var(--navitem-hover);
  }
  
  .output-tab.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
  }
  
  .output-panel {
    padding: 12px;
    max-height: 300px;
    overflow-y: auto;
  }
  
  .output-panel.hidden {
    display: none;
  }
  
  .output-text,
  .error-text {
    margin: 0;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 13px;
    line-height: 1.5;
    color: var(--text);
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  
  .error-text {
    color: #ef4444;
  }
  
  @media (max-width: 640px) {
    .toolbar {
      flex-wrap: wrap;
    }
    
    .link-full-editor {
      width: 100%;
      margin-left: 0;
      margin-top: 8px;
    }
  }
</style>
