---
interface Props {
  code: string;
  starterId: string;
  height?: number;
  instructions?: string;
  showFullEditorLink?: boolean;
  validationRegex?: string;
}

const { 
  code, 
  starterId, 
  height = 200,
  instructions,
  showFullEditorLink = true,
  validationRegex
} = Astro.props;

const runnerId = `runner-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="try-it-now-runner" data-runner-id={runnerId} data-validation-regex={validationRegex}>
  {instructions && (
    <div class="instructions">
      <span class="icon">‚ñ∂Ô∏è</span>
      <span>{instructions}</span>
    </div>
  )}
  
  <div class="editor-container">
    <div class="editor-wrapper" style={`height: ${height}px`}>
      <div id={`editor-${runnerId}`} class="monaco-editor-container"></div>
    </div>
    
    <div class="toolbar" id="lab-toolbar">
      <button class="btn btn-run" id="lab-run-button" data-action="run">
        <span class="icon">‚ñ∂</span>
        Run
      </button>
      <button class="btn btn-reset" id="lab-reset-button" data-action="reset">
        <span class="icon">‚Ü∫</span>
        Reset
      </button>
      {showFullEditorLink && (
        <a href={`/editor/?week=01&starter=${starterId}`} class="link-full-editor" target="_blank">
          Open in full editor ‚Üó
        </a>
      )}
    </div>
  </div>
  
  <div class="output-container" id="lab-output" data-collapsed="true">
    <div class="output-header" data-action="toggle-output">
      <span class="icon">‚ñº</span>
      <span class="title">Output</span>
      <span class="status"></span>
    </div>
    <div class="output-content">
      <div class="output-tabs">
        <button class="output-tab active" data-tab="console">Console</button>
        <button class="output-tab" data-tab="errors">Errors</button>
      </div>
      <div class="output-panel" data-panel="console">
        <pre class="output-text"></pre>
      </div>
      <div class="output-panel hidden" data-panel="errors">
        <pre class="error-text"></pre>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ runnerId, code, starterId }}>
  (async () => {
    const container = document.querySelector(`[data-runner-id="${runnerId}"]`);
    if (!container) return;
    
    const editorDiv = container.querySelector(`#editor-${runnerId}`);
    const runBtn = container.querySelector('[data-action="run"]');
    const resetBtn = container.querySelector('[data-action="reset"]');
    const outputContainer = container.querySelector('.output-container');
    const outputHeader = container.querySelector('[data-action="toggle-output"]');
    const statusSpan = container.querySelector('.status');
    const consoleOutput = container.querySelector('[data-panel="console"] .output-text');
    const errorOutput = container.querySelector('[data-panel="errors"] .error-text');
    const outputTabs = container.querySelectorAll('.output-tab');
    const outputPanels = container.querySelectorAll('.output-panel');
    
    let editor = null;
    const originalCode = code;
    
    // Wait for Monaco to load
    const waitForMonaco = async () => {
      let attempts = 0;
      while (!window.monaco) {
        if (attempts++ > 50) throw new Error('Monaco failed to load');
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    };
    
    // Celebration animation when requirements are met
    const triggerCelebration = () => {
      // Create confetti container
      const confettiContainer = document.createElement('div');
      confettiContainer.className = 'celebration-confetti';
      document.body.appendChild(confettiContainer);
      
      // Create confetti pieces
      const colors = ['#4ec9b0', '#10b981', '#22c55e', '#34d399', '#6ee7b7', '#fbbf24', '#f59e0b'];
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti-piece';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        confetti.style.animationDuration = (Math.random() * 1 + 1.5) + 's';
        confettiContainer.appendChild(confetti);
      }
      
      // Show success banner
      const banner = document.createElement('div');
      banner.className = 'celebration-banner';
      banner.innerHTML = 'üéâ Lab Complete! Great work!';
      container.insertBefore(banner, container.firstChild);
      
      // Remove confetti after animation
      setTimeout(() => {
        confettiContainer.remove();
      }, 3000);
    };
    
    // ===== C# IntelliSense Data =====
    const CSHARP_KEYWORDS = [
      'abstract', 'as', 'base', 'bool', 'break', 'byte', 'case', 'catch', 'char', 'checked',
      'class', 'const', 'continue', 'decimal', 'default', 'delegate', 'do', 'double', 'else',
      'enum', 'event', 'explicit', 'extern', 'false', 'finally', 'fixed', 'float', 'for',
      'foreach', 'goto', 'if', 'implicit', 'in', 'int', 'interface', 'internal', 'is', 'lock',
      'long', 'namespace', 'new', 'null', 'object', 'operator', 'out', 'override', 'params',
      'private', 'protected', 'public', 'readonly', 'ref', 'return', 'sbyte', 'sealed', 'short',
      'sizeof', 'stackalloc', 'static', 'string', 'struct', 'switch', 'this', 'throw', 'true',
      'try', 'typeof', 'uint', 'ulong', 'unchecked', 'unsafe', 'ushort', 'using', 'virtual',
      'void', 'volatile', 'while', 'var', 'async', 'await', 'dynamic', 'nameof', 'record'
    ];

    const SYSTEM_CLASSES = [
      { name: 'Console', detail: 'class System.Console', doc: 'Standard input, output, and error streams.' },
      { name: 'String', detail: 'class System.String', doc: 'Represents text as UTF-16 code units.' },
      { name: 'Math', detail: 'static class System.Math', doc: 'Common mathematical functions.' },
      { name: 'Convert', detail: 'static class System.Convert', doc: 'Converts base data types.' },
      { name: 'DateTime', detail: 'struct System.DateTime', doc: 'Represents an instant in time.' },
      { name: 'Random', detail: 'class System.Random', doc: 'Pseudo-random number generator.' },
      { name: 'Array', detail: 'class System.Array', doc: 'Methods for arrays.' },
      { name: 'List', detail: 'class List<T>', doc: 'Strongly typed list.' },
      { name: 'Dictionary', detail: 'class Dictionary<K,V>', doc: 'Key-value collection.' },
      { name: 'Exception', detail: 'class System.Exception', doc: 'Represents errors.' },
    ];

    const CONSOLE_MEMBERS = [
      { label: 'WriteLine', text: 'WriteLine($0);', detail: 'void WriteLine(string? value)', doc: 'Writes a line to console.' },
      { label: 'Write', text: 'Write($0);', detail: 'void Write(string? value)', doc: 'Writes to console.' },
      { label: 'ReadLine', text: 'ReadLine()', detail: 'string? ReadLine()', doc: 'Reads a line from input.' },
      { label: 'ReadKey', text: 'ReadKey()', detail: 'ConsoleKeyInfo ReadKey()', doc: 'Reads next key press.' },
      { label: 'Clear', text: 'Clear()', detail: 'void Clear()', doc: 'Clears the console.' },
      { label: 'ForegroundColor', text: 'ForegroundColor = ConsoleColor.$0', detail: 'ConsoleColor', doc: 'Text color.' },
      { label: 'BackgroundColor', text: 'BackgroundColor = ConsoleColor.$0', detail: 'ConsoleColor', doc: 'Background color.' },
      { label: 'ResetColor', text: 'ResetColor()', detail: 'void ResetColor()', doc: 'Resets colors.' },
    ];

    const MATH_MEMBERS = [
      { label: 'Abs', text: 'Abs($0)', detail: 'T Math.Abs(T value)', doc: 'Absolute value.' },
      { label: 'Max', text: 'Max($1, $2)', detail: 'T Math.Max(T, T)', doc: 'Returns larger of two.' },
      { label: 'Min', text: 'Min($1, $2)', detail: 'T Math.Min(T, T)', doc: 'Returns smaller of two.' },
      { label: 'Pow', text: 'Pow($1, $2)', detail: 'double Math.Pow(x, y)', doc: 'Power function.' },
      { label: 'Sqrt', text: 'Sqrt($0)', detail: 'double Math.Sqrt(d)', doc: 'Square root.' },
      { label: 'Round', text: 'Round($0)', detail: 'double Math.Round(value)', doc: 'Rounds to nearest integer.' },
      { label: 'Floor', text: 'Floor($0)', detail: 'double Math.Floor(d)', doc: 'Largest integer ‚â§ number.' },
      { label: 'Ceiling', text: 'Ceiling($0)', detail: 'double Math.Ceiling(a)', doc: 'Smallest integer ‚â• number.' },
      { label: 'PI', text: 'PI', detail: 'const double = 3.14159...', doc: 'Pi constant.' },
    ];

    const STRING_MEMBERS = [
      { label: 'Length', text: 'Length', detail: 'int Length', doc: 'Number of characters.', isProp: true },
      { label: 'ToUpper', text: 'ToUpper()', detail: 'string ToUpper()', doc: 'Converts to uppercase.' },
      { label: 'ToLower', text: 'ToLower()', detail: 'string ToLower()', doc: 'Converts to lowercase.' },
      { label: 'Trim', text: 'Trim()', detail: 'string Trim()', doc: 'Removes whitespace.' },
      { label: 'Split', text: 'Split($0)', detail: 'string[] Split(char)', doc: 'Splits into array.' },
      { label: 'Contains', text: 'Contains($0)', detail: 'bool Contains(string)', doc: 'Checks if contains.' },
      { label: 'Replace', text: 'Replace($1, $2)', detail: 'string Replace(old, new)', doc: 'Replaces text.' },
      { label: 'Substring', text: 'Substring($0)', detail: 'string Substring(start)', doc: 'Gets portion.' },
      { label: 'IndexOf', text: 'IndexOf($0)', detail: 'int IndexOf(value)', doc: 'Finds position.' },
      { label: 'StartsWith', text: 'StartsWith($0)', detail: 'bool StartsWith(value)', doc: 'Checks start.' },
      { label: 'EndsWith', text: 'EndsWith($0)', detail: 'bool EndsWith(value)', doc: 'Checks end.' },
    ];

    const LIST_MEMBERS = [
      { label: 'Add', text: 'Add($0)', detail: 'void Add(T item)', doc: 'Adds to end.' },
      { label: 'Remove', text: 'Remove($0)', detail: 'bool Remove(T item)', doc: 'Removes first occurrence.' },
      { label: 'RemoveAt', text: 'RemoveAt($0)', detail: 'void RemoveAt(int index)', doc: 'Removes at index.' },
      { label: 'Clear', text: 'Clear()', detail: 'void Clear()', doc: 'Removes all.' },
      { label: 'Contains', text: 'Contains($0)', detail: 'bool Contains(T item)', doc: 'Checks if exists.' },
      { label: 'IndexOf', text: 'IndexOf($0)', detail: 'int IndexOf(T item)', doc: 'Finds index.' },
      { label: 'Insert', text: 'Insert($1, $2)', detail: 'void Insert(index, item)', doc: 'Inserts at index.' },
      { label: 'Sort', text: 'Sort()', detail: 'void Sort()', doc: 'Sorts elements.' },
      { label: 'Reverse', text: 'Reverse()', detail: 'void Reverse()', doc: 'Reverses order.' },
      { label: 'Count', text: 'Count', detail: 'int Count', doc: 'Number of elements.', isProp: true },
      { label: 'ToArray', text: 'ToArray()', detail: 'T[] ToArray()', doc: 'Copies to array.' },
    ];

    const CONVERT_MEMBERS = [
      { label: 'ToInt32', text: 'ToInt32($0)', detail: 'int ToInt32(value)', doc: 'Converts to int.' },
      { label: 'ToDouble', text: 'ToDouble($0)', detail: 'double ToDouble(value)', doc: 'Converts to double.' },
      { label: 'ToString', text: 'ToString($0)', detail: 'string ToString(value)', doc: 'Converts to string.' },
      { label: 'ToBoolean', text: 'ToBoolean($0)', detail: 'bool ToBoolean(value)', doc: 'Converts to bool.' },
    ];

    const CODE_SNIPPETS = [
      { label: 'namespace', text: 'namespace ${1:MyNamespace}\\n{\\n\\t$0\\n}', detail: 'namespace declaration' },
      { label: 'class', text: 'class ${1:MyClass}\\n{\\n\\t$0\\n}', detail: 'class declaration' },
      { label: 'public class', text: 'public class ${1:MyClass}\\n{\\n\\t$0\\n}', detail: 'public class' },
      { label: 'static class', text: 'static class ${1:MyClass}\\n{\\n\\t$0\\n}', detail: 'static class' },
      { label: 'interface', text: 'interface ${1:IMyInterface}\\n{\\n\\t$0\\n}', detail: 'interface' },
      { label: 'Main', text: 'static void Main(string[] args)\\n{\\n\\t$0\\n}', detail: 'Main method' },
      { label: 'method', text: '${1:void} ${2:MyMethod}(${3})\\n{\\n\\t$0\\n}', detail: 'method' },
      { label: 'property', text: 'public ${1:string} ${2:MyProperty} { get; set; }', detail: 'auto property' },
      { label: 'ctor', text: 'public ${1:ClassName}(${2})\\n{\\n\\t$0\\n}', detail: 'constructor' },
      { label: 'if', text: 'if (${1:condition})\\n{\\n\\t$0\\n}', detail: 'if statement' },
      { label: 'ifelse', text: 'if (${1:condition})\\n{\\n\\t$2\\n}\\nelse\\n{\\n\\t$0\\n}', detail: 'if-else' },
      { label: 'for', text: 'for (int ${1:i} = 0; ${1:i} < ${2:length}; ${1:i}++)\\n{\\n\\t$0\\n}', detail: 'for loop' },
      { label: 'foreach', text: 'foreach (var ${1:item} in ${2:collection})\\n{\\n\\t$0\\n}', detail: 'foreach loop' },
      { label: 'while', text: 'while (${1:condition})\\n{\\n\\t$0\\n}', detail: 'while loop' },
      { label: 'switch', text: 'switch (${1:variable})\\n{\\n\\tcase ${2:value}:\\n\\t\\t$0\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tbreak;\\n}', detail: 'switch' },
      { label: 'try', text: 'try\\n{\\n\\t$0\\n}\\ncatch (Exception ex)\\n{\\n\\t\\n}', detail: 'try-catch' },
      { label: 'cw', text: 'Console.WriteLine($0);', detail: 'Console.WriteLine' },
      { label: 'cr', text: 'Console.ReadLine()', detail: 'Console.ReadLine' },
    ];

    const NAMESPACES = [
      { name: 'System', doc: 'Fundamental classes and base types.' },
      { name: 'System.Collections.Generic', doc: 'Generic collections.' },
      { name: 'System.Linq', doc: 'LINQ queries.' },
      { name: 'System.Text', doc: 'Text encoding.' },
      { name: 'System.IO', doc: 'File and stream I/O.' },
    ];
    
    try {
      await waitForMonaco();
      
      // Register C# completion provider (once per page)
      if (!window.__csharpCompletionRegistered) {
        window.__csharpCompletionRegistered = true;
        monaco.languages.registerCompletionItemProvider('csharp', {
          triggerCharacters: ['.', ' '],
          provideCompletionItems: (model, position) => {
            const word = model.getWordUntilPosition(position);
            const range = {
              startLineNumber: position.lineNumber,
              endLineNumber: position.lineNumber,
              startColumn: word.startColumn,
              endColumn: word.endColumn
            };
            
            const lineContent = model.getLineContent(position.lineNumber);
            const textBefore = lineContent.substring(0, position.column - 1);
            const suggestions = [];

            // Helper to add members
            const addMembers = (members) => {
              members.forEach(m => {
                suggestions.push({
                  label: m.label,
                  kind: m.isProp ? monaco.languages.CompletionItemKind.Property : monaco.languages.CompletionItemKind.Method,
                  insertText: m.text,
                  insertTextRules: m.text.includes('$') ? monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet : undefined,
                  detail: m.detail,
                  documentation: m.doc,
                  range
                });
              });
            };

            // ===== CONTEXT: After "using " =====
            if (textBefore.match(/using\s+$/)) {
              NAMESPACES.forEach(ns => {
                suggestions.push({
                  label: ns.name,
                  kind: monaco.languages.CompletionItemKind.Module,
                  insertText: ns.name + ';',
                  detail: 'namespace',
                  documentation: ns.doc,
                  range
                });
              });
              return { suggestions };
            }

            // ===== CONTEXT: After "Console." =====
            if (textBefore.match(/Console\.$/)) {
              addMembers(CONSOLE_MEMBERS);
              return { suggestions };
            }

            // ===== CONTEXT: After "Math." =====
            if (textBefore.match(/Math\.$/)) {
              addMembers(MATH_MEMBERS);
              return { suggestions };
            }

            // ===== CONTEXT: After "Convert." =====
            if (textBefore.match(/Convert\.$/)) {
              addMembers(CONVERT_MEMBERS);
              return { suggestions };
            }

            // ===== CONTEXT: After list variable =====
            if (textBefore.match(/\b(list|items|collection|numbers|names|words|data)\.\s*$/i)) {
              addMembers(LIST_MEMBERS);
              return { suggestions };
            }

            // ===== CONTEXT: After string variable or literal =====
            if (textBefore.match(/"\s*\.\s*$/) || textBefore.match(/\b(str|name|text|input|line|word|s|message)\.\s*$/i)) {
              addMembers(STRING_MEMBERS);
              return { suggestions };
            }

            // ===== CONTEXT: After any identifier with dot =====
            if (textBefore.match(/\w+\.\s*$/)) {
              addMembers(STRING_MEMBERS);
              addMembers(LIST_MEMBERS);
              suggestions.push({
                label: 'ToString', kind: monaco.languages.CompletionItemKind.Method,
                insertText: 'ToString()', detail: 'string ToString()', 
                documentation: 'Returns string representation.', range
              });
              return { suggestions };
            }

            // ===== GENERAL CONTEXT =====
            const currentWord = word.word.toLowerCase();

            // Snippets (prioritized)
            CODE_SNIPPETS.forEach(s => {
              if (currentWord === '' || s.label.toLowerCase().startsWith(currentWord)) {
                suggestions.push({
                  label: s.label,
                  kind: monaco.languages.CompletionItemKind.Snippet,
                  insertText: s.text,
                  insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                  detail: s.detail,
                  range,
                  sortText: '0' + s.label
                });
              }
            });

            // Keywords
            CSHARP_KEYWORDS.forEach(kw => {
              if (currentWord === '' || kw.toLowerCase().startsWith(currentWord)) {
                suggestions.push({
                  label: kw,
                  kind: monaco.languages.CompletionItemKind.Keyword,
                  insertText: kw,
                  detail: 'keyword',
                  range,
                  sortText: '1' + kw
                });
              }
            });

            // System classes
            SYSTEM_CLASSES.forEach(cls => {
              if (currentWord === '' || cls.name.toLowerCase().startsWith(currentWord)) {
                suggestions.push({
                  label: cls.name,
                  kind: monaco.languages.CompletionItemKind.Class,
                  insertText: cls.name,
                  detail: cls.detail,
                  documentation: cls.doc,
                  range,
                  sortText: '2' + cls.name
                });
              }
            });

            // Console methods (qualified)
            if (currentWord === '' || 'console'.startsWith(currentWord)) {
              suggestions.push({
                label: 'Console.WriteLine',
                kind: monaco.languages.CompletionItemKind.Method,
                insertText: 'Console.WriteLine($0);',
                insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                detail: 'void Console.WriteLine(string value)',
                documentation: 'Writes a line to console output.',
                range,
                sortText: '3Console.WriteLine'
              });
              suggestions.push({
                label: 'Console.ReadLine',
                kind: monaco.languages.CompletionItemKind.Method,
                insertText: 'Console.ReadLine()',
                detail: 'string Console.ReadLine()',
                documentation: 'Reads a line from console input.',
                range,
                sortText: '3Console.ReadLine'
              });
            }
            
            return { suggestions };
          }
        });
      }
      
      // Initialize Monaco editor - always use vs-dark for consistent styling
      editor = monaco.editor.create(editorDiv, {
        value: originalCode,
        language: 'csharp',
        theme: 'vs-dark',
        minimap: { enabled: false },
        fontSize: 14,
        lineNumbers: 'on',
        scrollBeyondLastLine: false,
        automaticLayout: true,
        tabSize: 4,
        quickSuggestions: {
          other: true,
          comments: false,
          strings: false,
        },
        suggestOnTriggerCharacters: true,
        parameterHints: { enabled: true },
        autoClosingBrackets: 'always',
        autoClosingQuotes: 'always',
        autoIndent: 'full',
        renderLineHighlight: 'all',
      });
      
      // Theme sync removed - always use vs-dark for code snippets
      
    } catch (err) {
      console.error('[TryItNowRunner] Monaco init failed:', err);
      editorDiv.innerHTML = `<textarea style="width:100%;height:100%;font-family:monospace;padding:8px;">${originalCode}</textarea>`;
    }
    
    // Expand/collapse output
    function toggleOutput(forceExpand = false) {
      const isCollapsed = outputContainer.dataset.collapsed === 'true';
      if (forceExpand || isCollapsed) {
        outputContainer.dataset.collapsed = 'false';
        outputHeader.querySelector('.icon').textContent = '‚ñ≤';
        // Scroll into view
        setTimeout(() => {
          outputContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100);
      } else {
        outputContainer.dataset.collapsed = 'true';
        outputHeader.querySelector('.icon').textContent = '‚ñº';
      }
    }
    
    outputHeader.addEventListener('click', () => toggleOutput());
    
    // Output tab switching
    outputTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const targetPanel = tab.dataset.tab;
        outputTabs.forEach(t => t.classList.toggle('active', t === tab));
        outputPanels.forEach(p => {
          p.classList.toggle('hidden', p.dataset.panel !== targetPanel);
        });
      });
    });
    
    // Run code
    async function runCode() {
      const currentCode = editor ? editor.getValue() : editorDiv.querySelector('textarea')?.value || originalCode;
      
      console.log(`[TryItNowRunner ${runnerId}] Running code for starterId: ${starterId}`);
      console.log(`[TryItNowRunner ${runnerId}] Code preview:`, currentCode.substring(0, 100));
      console.log(`[TryItNowRunner ${runnerId}] Output elements:`, { 
        consoleOutput: consoleOutput?.tagName,
        errorOutput: errorOutput?.tagName,
        statusSpan: statusSpan?.tagName
      });
      
      runBtn.disabled = true;
      runBtn.innerHTML = '<span class="icon">‚è≥</span> Running...';
      statusSpan.textContent = '‚è≥ Running...';
      
      // Expand output and clear
      toggleOutput(true);
      consoleOutput.textContent = '(running...)';
      errorOutput.textContent = '';
      
      try {
        const response = await fetch('/api/compile-and-run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            code: currentCode,
            starterId: starterId,
          }),
        });
        
        console.log(`[TryItNowRunner ${runnerId}] Response status:`, response.status);
        
        if (!response.ok) {
          const errorBody = await response.text();
          console.error(`[TryItNowRunner ${runnerId}] Error response body:`, errorBody);
          throw new Error(`HTTP ${response.status}: ${errorBody}`);
        }
        
        const result = await response.json();
        console.log(`[TryItNowRunner ${runnerId}] Result:`, result);
        
        // Check validation regex
        let isValidated = false;
        const validationRegexStr = container.getAttribute('data-validation-regex');
        if (result.stdout && validationRegexStr) {
          const regexParts = validationRegexStr.match(/\/(.*)\/(.*)/);  
          if (regexParts) {
            const regex = new RegExp(regexParts[1], regexParts[2]);
            if (regex.test(result.stdout)) {
              isValidated = true;
              statusSpan.innerHTML = '<span style="color: #4ec9b0; font-weight: bold;">‚úÖ Requirements Met</span>';
              
              // Trigger celebration animation
              triggerCelebration();
              
              // Save lab completion for gradebook (if this is a lab)
              try {
                if (window.__auth && typeof window.__auth.getAccessToken === 'function') {
                  const token = await window.__auth.getAccessToken().catch(() => null);
                  if (token) {
                    // Derive lab ID from starterId or URL path
                    const labIdFromStarter = starterId?.match(/^(week-\d+)-/)?.[0] + 'lab';
                    const weekMatch = window.location.pathname.match(/\/week-(\d+)\//);
                    const labId = labIdFromStarter || (weekMatch ? `week-${weekMatch[1].padStart(2, '0')}-lab` : null);
                    
                    if (labId) {
                      await fetch('/api/progress-update', {
                        method: 'POST',
                        headers: { 
                          'Authorization': `Bearer ${token}`,
                          'Content-Type': 'application/json' 
                        },
                        body: JSON.stringify({
                          pageId: labId,
                          status: 'completed',
                          score: 100
                        }),
                      }).catch(() => {});
                      console.log('[TryItNowRunner] Lab completion recorded:', labId);
                    }
                  }
                }
              } catch (labErr) {
                console.error('[TryItNowRunner] Lab completion save failed:', labErr);
              }
            }
          }
        }
        
        // Display output
        consoleOutput.textContent = result.stdout || '(no output)';
        
        // Display errors
        const hasErrors = result.stderr || (result.diagnostics && result.diagnostics.some(d => d.severity === 'Error'));
        if (hasErrors) {
          let errorText = '';
          if (result.stderr) {
            errorText += result.stderr + '\n\n';
          }
          if (result.diagnostics) {
            result.diagnostics.forEach(d => {
              if (d.severity === 'Error') {
                errorText += `Line ${d.line}: ${d.message}\n`;
              }
            });
          }
          errorOutput.textContent = errorText;
          statusSpan.textContent = '‚ö†Ô∏è Completed with errors';
          statusSpan.style.color = '#ef4444';
          
          // Auto-switch to errors tab
          outputTabs.forEach(t => t.classList.toggle('active', t.dataset.tab === 'errors'));
          outputPanels.forEach(p => p.classList.toggle('hidden', p.dataset.panel !== 'errors'));
        } else {
          // Only set generic success if validation hasn't already passed
          if (!isValidated) {
            statusSpan.textContent = '‚úì Execution Successful';
            statusSpan.style.color = '#10b981';
          }
          
          // Participation Heartbeat (optional - only if logged in)
          try {
            if (window.__auth && typeof window.__auth.getAccessToken === 'function') {
              const token = await window.__auth.getAccessToken().catch(() => null);
              if (token) {
                // Build participation ID: combine page path with runner ID
                const pageSlug = window.location.pathname.replace(/\/$/, '');
                const participationId = `${pageSlug}:tryit:${starterId || runnerId}`;
                
                await fetch('/api/progress-update', {
                  method: 'POST',
                  headers: { 
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json' 
                  },
                  body: JSON.stringify({
                    pageId: participationId,
                    status: 'participated',
                    type: 'tryit'
                  }),
                }).catch(() => {}); // Ignore progress update failures
                
                console.log('[TryItNowRunner] Participation recorded:', participationId);
              }
            }
          } catch (heartbeatErr) {
            // Silently ignore - participation tracking is optional
          }
        }
        
      } catch (err) {
        console.error('[TryItNowRunner] Run failed:', err);
        errorOutput.textContent = `Failed to run code: ${err.message}`;
        statusSpan.textContent = '‚úó Error';
        statusSpan.style.color = '#ef4444';
      } finally {
        runBtn.disabled = false;
        runBtn.innerHTML = '<span class="icon">‚ñ∂</span> Run';
      }
    }
    
    // Reset code
    function resetCode() {
      if (editor) {
        editor.setValue(originalCode);
      } else {
        const textarea = editorDiv.querySelector('textarea');
        if (textarea) textarea.value = originalCode;
      }
      consoleOutput.textContent = '';
      errorOutput.textContent = '';
      statusSpan.textContent = '';
      outputContainer.dataset.collapsed = 'true';
      outputHeader.querySelector('.icon').textContent = '‚ñº';
    }
    
    runBtn.addEventListener('click', runCode);
    resetBtn.addEventListener('click', resetCode);
    
    // Keyboard shortcut: Ctrl+Enter to run
    if (editor) {
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, runCode);
    }
    
  })();
</script>

<style>
  .try-it-now-runner {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    margin: 20px 0;
  }
  
  .instructions {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    background: var(--accent);
    color: white;
    font-weight: 500;
    font-size: 14px;
  }
  
  .instructions .icon {
    font-size: 16px;
  }
  
  .editor-container {
    border-bottom: 1px solid var(--border);
  }
  
  .editor-wrapper {
    border-bottom: 1px solid var(--border);
  }
  
  .monaco-editor-container {
    height: 100%;
    width: 100%;
  }
  
  .toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    background: var(--panel2);
  }
  
  .btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 14px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .btn:hover:not(:disabled) {
    background: var(--accent-hover);
  }
  
  .btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  .btn-reset {
    background: var(--panel);
    color: var(--text);
    border: 1px solid var(--border);
  }
  
  .btn-reset:hover:not(:disabled) {
    background: var(--navitem-hover);
  }
  
  .link-full-editor {
    margin-left: auto;
    font-size: 13px;
    color: var(--text-muted);
    text-decoration: none;
    transition: color 0.2s;
  }
  
  .link-full-editor:hover {
    color: var(--accent);
    text-decoration: underline;
  }
  
  .output-container {
    border-top: 1px solid var(--border);
  }
  
  .output-container[data-collapsed="true"] .output-content {
    display: none;
  }
  
  .output-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    background: var(--panel2);
    cursor: pointer;
    user-select: none;
    transition: background 0.2s;
  }
  
  .output-header:hover {
    background: var(--navitem-hover);
  }
  
  .output-header .icon {
    font-size: 12px;
    transition: transform 0.2s;
  }
  
  .output-header .title {
    font-weight: 600;
    color: var(--text);
    font-size: 14px;
  }
  
  .output-header .status {
    margin-left: auto;
    font-size: 13px;
    font-weight: 500;
  }
  
  .output-tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    background: var(--panel2);
  }
  
  .output-tab {
    padding: 8px 16px;
    background: transparent;
    border: none;
    border-bottom: 2px solid transparent;
    color: var(--text-muted);
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .output-tab:hover {
    color: var(--text);
    background: var(--navitem-hover);
  }
  
  .output-tab.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
  }
  
  .output-panel {
    padding: 12px;
    max-height: 300px;
    overflow-y: auto;
  }
  
  .output-panel.hidden {
    display: none;
  }
  
  .output-text,
  .error-text {
    margin: 0;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 13px;
    line-height: 1.5;
    color: var(--text);
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  
  .error-text {
    color: #ef4444;
  }
  
  @media (max-width: 640px) {
    .toolbar {
      flex-wrap: wrap;
    }
    
    .link-full-editor {
      width: 100%;
      margin-left: 0;
      margin-top: 8px;
    }
  }
  
  /* Celebration animation styles */
  .celebration-banner {
    background: linear-gradient(135deg, #4ec9b0 0%, #10b981 100%);
    color: white;
    padding: 16px 20px;
    text-align: center;
    font-size: 18px;
    font-weight: 600;
    border-radius: 8px 8px 0 0;
    animation: bannerSlideIn 0.5s ease-out;
  }
  
  @keyframes bannerSlideIn {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

<style is:global>
  .celebration-confetti {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 9999;
    overflow: hidden;
  }
  
  .confetti-piece {
    position: absolute;
    top: -10px;
    width: 10px;
    height: 10px;
    border-radius: 2px;
    animation: confettiFall 2s ease-out forwards;
  }
  
  @keyframes confettiFall {
    0% {
      transform: translateY(0) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) rotate(720deg);
      opacity: 0;
    }
  }
</style>
