---
interface Props {
  code: string;
  starterId?: string;
  stdin?: string;
  height?: number;
  showOpenEditor?: boolean;
  openEditorHref?: string;
}

const {
  code,
  starterId = "inline-snippet",
  stdin = "",
  height = 180,
  showOpenEditor = true,
  openEditorHref,
} = Astro.props;

const runnerUrl = import.meta.env.PUBLIC_RUNNER_URL ?? "";
const snippetId = `snippet-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="runnable-snippet" data-snippet-id={snippetId}>
  <div class="snippet-header">
    <span class="snippet-label">Try it yourself:</span>
    <div class="snippet-actions">
      <button class="snippet-btn snippet-run" type="button">▶ Run</button>
      <button class="snippet-btn snippet-reset" type="button">↺ Reset</button>
      {showOpenEditor && (
        <a 
          href={openEditorHref || `/editor/?starter=${starterId}`}
          class="snippet-btn snippet-open-editor"
        >
          Open in Editor →
        </a>
      )}
    </div>
  </div>
  
  <div class="snippet-editor" style={`height: ${height}px;`}></div>
  
  <div class="snippet-output-drawer collapsed">
    <div class="snippet-output-header">
      <span class="snippet-output-title">Output <span class="snippet-output-toggle">▾</span></span>
      <span class="snippet-output-status">Click Run to see output</span>
    </div>
    <div class="snippet-output-content">
      <div class="snippet-output-tabs">
        <button class="snippet-output-tab active" data-tab="console">Console</button>
        <button class="snippet-output-tab" data-tab="errors">Errors</button>
        <button class="snippet-output-tab" data-tab="diagnostics">Diagnostics</button>
      </div>
      <div class="snippet-output-body">
        <div class="snippet-tab-pane active" data-pane="console">
          <pre class="snippet-output-pre">(no output yet)</pre>
        </div>
        <div class="snippet-tab-pane" data-pane="errors">
          <pre class="snippet-output-pre">(no errors yet)</pre>
        </div>
        <div class="snippet-tab-pane" data-pane="diagnostics">
          <ul class="snippet-diagnostics-list"></ul>
          <div class="snippet-diagnostics-empty hint">(no diagnostics yet)</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="/monaco/vs/loader.js" type="text/javascript"></script>
<script define:vars={{ code, starterId, stdin, runnerUrl, snippetId }}>
  (() => {
    const container = document.querySelector(`[data-snippet-id="${snippetId}"]`);
    if (!container) return;
    
    const editorHost = container.querySelector('.snippet-editor');
    const btnRun = container.querySelector('.snippet-run');
    const btnReset = container.querySelector('.snippet-reset');
    const drawer = container.querySelector('.snippet-output-drawer');
    const drawerHeader = container.querySelector('.snippet-output-header');
    const outputStatus = container.querySelector('.snippet-output-status');
    const consolePane = container.querySelector('[data-pane="console"] .snippet-output-pre');
    const errorsPane = container.querySelector('[data-pane="errors"] .snippet-output-pre');
    const diagnosticsList = container.querySelector('.snippet-diagnostics-list');
    const diagnosticsEmpty = container.querySelector('.snippet-diagnostics-empty');
    
    let editorInstance = null;
    const originalCode = code;
    const storageKey = `cis118m:snippet:${window.location.pathname}:${snippetId}`;
    
    // Load saved code or use original
    const getInitialCode = () => {
      try {
        const saved = localStorage.getItem(storageKey);
        return saved || originalCode;
      } catch {
        return originalCode;
      }
    };
    
    // Save code to localStorage
    const saveCode = (value) => {
      try {
        localStorage.setItem(storageKey, value);
      } catch (err) {
        console.error('Failed to save snippet code:', err);
      }
    };
    
    // Runner utilities
    const resolveRunnerUrl = (publicUrl) => {
      const trimmed = (publicUrl ?? "").trim();
      const normalized = trimmed.replace(/\/+$/, "");
      return normalized || window.location.origin;
    };
    
    const runnerBase = resolveRunnerUrl(runnerUrl);
    
    // Toggle drawer
    let drawerExpanded = false;
    const toggleDrawer = () => {
      drawerExpanded = !drawerExpanded;
      drawer.classList.toggle('collapsed', !drawerExpanded);
      container.querySelector('.snippet-output-toggle').textContent = drawerExpanded ? '▴' : '▾';
    };
    
    const openDrawer = () => {
      if (!drawerExpanded) toggleDrawer();
    };
    
    drawerHeader.addEventListener('click', toggleDrawer);
    
    // Tab switching
    container.querySelectorAll('.snippet-output-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;
        container.querySelectorAll('.snippet-output-tab').forEach(t => t.classList.remove('active'));
        container.querySelectorAll('.snippet-tab-pane').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        container.querySelector(`[data-pane="${targetTab}"]`).classList.add('active');
      });
    });
    
    // Apply Monaco markers
    const applyMarkers = (diagnostics) => {
      if (!editorInstance || !window.monaco) return;
      const model = editorInstance.getModel();
      if (!model) return;
      
      const lineCount = model.getLineCount();
      const clampLine = (line) => Math.min(Math.max(line, 1), lineCount);
      const clampCol = (line, col) => {
        const max = model.getLineMaxColumn(line);
        return Math.min(Math.max(col, 1), max);
      };
      
      const markers = (diagnostics || []).map((d) => {
        const startLine = clampLine(d.line);
        const startCol = clampCol(startLine, d.column);
        return {
          startLineNumber: startLine,
          startColumn: startCol,
          endLineNumber: startLine,
          endColumn: startCol + (d.length || 1),
          message: d.message || "Error",
          severity: d.severity === "error" ? monaco.MarkerSeverity.Error : monaco.MarkerSeverity.Warning,
        };
      });
      
      monaco.editor.setModelMarkers(model, "csharp", markers);
      
      // Scroll to first error
      if (markers.length > 0) {
        editorInstance.revealLineInCenter(markers[0].startLineNumber);
      }
    };
    
    // Render diagnostics list
    const renderDiagnostics = (diagnostics) => {
      diagnosticsList.innerHTML = '';
      if (!diagnostics || diagnostics.length === 0) {
        diagnosticsEmpty.style.display = 'block';
        return;
      }
      diagnosticsEmpty.style.display = 'none';
      diagnostics.forEach((d) => {
        const li = document.createElement('li');
        li.className = `diagnostic-item diagnostic-${d.severity}`;
        li.textContent = `Line ${d.line}, Col ${d.column}: ${d.message}`;
        diagnosticsList.appendChild(li);
      });
    };
    
    // Run code
    const runCode = async () => {
      if (!editorInstance) return;
      
      btnRun.disabled = true;
      outputStatus.textContent = 'Running...';
      consolePane.textContent = '(running...)';
      errorsPane.textContent = '(no errors yet)';
      renderDiagnostics([]);
      applyMarkers([]);
      openDrawer();
      
      try {
        const currentCode = editorInstance.getValue();
        const response = await fetch(`${runnerBase}/api/run`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            starterId: starterId,
            files: { "Program.cs": currentCode },
            stdin: stdin || "",
          }),
        });
        
        if (!response.ok) {
          throw new Error(`Runner returned ${response.status}`);
        }
        
        const result = await response.json();
        
        // Update output
        consolePane.textContent = result.stdout || '(no output)';
        errorsPane.textContent = result.stderr || '(no errors)';
        
        // Update diagnostics
        if (result.diagnostics && result.diagnostics.length > 0) {
          renderDiagnostics(result.diagnostics);
          applyMarkers(result.diagnostics);
        }
        
        // Check if there are actual errors (not just warnings)
        const hasErrors = result.stderr || 
          (result.diagnostics && result.diagnostics.some(d => d.severity === 'Error'));
        
        outputStatus.textContent = hasErrors ? 'Completed with errors' : 'Success';
      } catch (err) {
        console.error('Run failed:', err);
        errorsPane.textContent = `Error: ${err.message}`;
        outputStatus.textContent = 'Run failed';
      } finally {
        btnRun.disabled = false;
      }
    };
    
    // Reset to original
    btnReset.addEventListener('click', () => {
      if (editorInstance) {
        editorInstance.setValue(originalCode);
        saveCode(originalCode);
        applyMarkers([]);
        renderDiagnostics([]);
      }
    });
    
    btnRun.addEventListener('click', runCode);
    
    // Initialize Monaco
    const initMonaco = () => {
      if (window.__monacoLoaded) {
        createEditor();
        return;
      }
      
      if (!window.require) {
        setTimeout(initMonaco, 100);
        return;
      }
      
      const r = window.require;
      r.config({ paths: { vs: '/monaco/vs' } });
      r(["vs/editor/editor.main"], () => {
        window.__monacoLoaded = true;
        createEditor();
      });
    };
    
    const createEditor = () => {
      if (!window.monaco) {
        setTimeout(createEditor, 100);
        return;
      }
      
      const initialCode = getInitialCode();
      
      // Get theme from document
      const theme = document.body.getAttribute('data-theme') === 'dark' ? 'vs-dark' : 'vs';
      
      editorInstance = monaco.editor.create(editorHost, {
        value: initialCode,
        language: 'csharp',
        theme: theme,
        automaticLayout: true,
        minimap: { enabled: false },
        fontSize: 13,
        lineNumbers: 'on',
        scrollBeyondLastLine: false,
      });
      
      // Save on change
      editorInstance.onDidChangeModelContent(() => {
        saveCode(editorInstance.getValue());
      });
      
      // Support Ctrl+Enter to run
      editorInstance.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {
        runCode();
      });
    };
    
    initMonaco();
  })();
</script>

<style>
  .runnable-snippet {
    margin: 2rem 0;
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    background: var(--bg-primary);
  }
  
  .snippet-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem 1rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border);
  }
  
  .snippet-label {
    font-weight: 600;
    font-size: 0.9rem;
    color: var(--text-primary);
  }
  
  .snippet-actions {
    display: flex;
    gap: 0.5rem;
  }
  
  .snippet-btn {
    padding: 0.4rem 0.8rem;
    font-size: 0.85rem;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg-primary);
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.2s;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
  }
  
  .snippet-btn:hover {
    background: var(--bg-hover);
    border-color: var(--accent);
  }
  
  .snippet-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .snippet-run {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
  }
  
  .snippet-run:hover:not(:disabled) {
    background: var(--accent-hover);
  }
  
  .snippet-editor {
    border-bottom: 1px solid var(--border);
  }
  
  .snippet-output-drawer {
    max-height: 400px;
    transition: max-height 0.3s;
  }
  
  .snippet-output-drawer.collapsed {
    max-height: 44px;
    overflow: hidden;
  }
  
  .snippet-output-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem 1rem;
    background: var(--bg-secondary);
    cursor: pointer;
    user-select: none;
  }
  
  .snippet-output-header:hover {
    background: var(--bg-hover);
  }
  
  .snippet-output-title {
    font-weight: 600;
    font-size: 0.9rem;
  }
  
  .snippet-output-status {
    font-size: 0.85rem;
    color: var(--text-secondary);
  }
  
  .snippet-output-content {
    border-top: 1px solid var(--border);
  }
  
  .snippet-output-tabs {
    display: flex;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border);
  }
  
  .snippet-output-tab {
    padding: 0.4rem 0.8rem;
    font-size: 0.85rem;
    border: none;
    border-radius: 6px;
    background: transparent;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .snippet-output-tab.active {
    background: var(--bg-primary);
    color: var(--text-primary);
  }
  
  .snippet-output-body {
    padding: 1rem;
    max-height: 300px;
    overflow-y: auto;
  }
  
  .snippet-tab-pane {
    display: none;
  }
  
  .snippet-tab-pane.active {
    display: block;
  }
  
  .snippet-output-pre {
    margin: 0;
    padding: 0.75rem;
    background: var(--code-bg);
    border-radius: 6px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9rem;
    white-space: pre-wrap;
    word-wrap: break-word;
    color: var(--text-primary);
  }
  
  .snippet-diagnostics-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  
  .diagnostic-item {
    padding: 0.5rem 0.75rem;
    margin-bottom: 0.5rem;
    background: var(--bg-secondary);
    border-left: 3px solid var(--accent);
    border-radius: 4px;
    font-size: 0.9rem;
  }
  
  .diagnostic-error {
    border-left-color: #ef4444;
  }
  
  .diagnostic-warning {
    border-left-color: #f59e0b;
  }
  
  .snippet-diagnostics-empty {
    color: var(--text-secondary);
    font-style: italic;
  }
</style>
