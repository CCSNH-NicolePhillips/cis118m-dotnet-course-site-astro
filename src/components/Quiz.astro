---
interface QuizQuestion {
  id: string;
  type: 'multiple-choice' | 'true-false' | 'checkbox';
  question: string;
  options?: string[];
  correctAnswer: string | string[];
  explanation?: string;
}

interface Props {
  quizId: string;
  title: string;
  questions: QuizQuestion[];
  passingScore?: number;
  maxAttempts?: number; // Set to 0 or Infinity for unlimited
}

const { quizId, title, questions, passingScore = 70, maxAttempts = 2 } = Astro.props;
// Use a large number for "unlimited" since Infinity can't be serialized to JSON
const effectiveMaxAttempts = maxAttempts === 0 ? 999999 : maxAttempts;
---

<div class="quiz-container" data-quiz-id={quizId}>
  <div class="quiz-header">
    <h2>{title}</h2>
    <p class="quiz-info">Passing score: {passingScore}%</p>
  </div>
  
  <form class="quiz-form" id={`quiz-form-${quizId}`}>
    {questions.map((q, index) => (
      <div class="quiz-question" data-question-id={q.id}>
        <div class="question-number">Question {index + 1}</div>
        <p class="question-text">{q.question}</p>
        
        {q.type === 'multiple-choice' && q.options && (
          <div class="options">
            {q.options.map((option, optIndex) => (
              <label class="option-label">
                <input 
                  type="radio" 
                  name={`q-${q.id}`} 
                  value={option}
                  required
                />
                <span>{option}</span>
              </label>
            ))}
          </div>
        )}
        
        {q.type === 'true-false' && (
          <div class="options">
            <label class="option-label">
              <input type="radio" name={`q-${q.id}`} value="True" required />
              <span>True</span>
            </label>
            <label class="option-label">
              <input type="radio" name={`q-${q.id}`} value="False" required />
              <span>False</span>
            </label>
          </div>
        )}
        
        {q.type === 'checkbox' && q.options && (
          <div class="options">
            {q.options.map((option) => (
              <label class="option-label">
                <input type="checkbox" name={`q-${q.id}`} value={option} />
                <span>{option}</span>
              </label>
            ))}
          </div>
        )}
      </div>
    ))}
    
    <button type="submit" class="submit-button" id={`submit-${quizId}`}>Submit Quiz</button>
  </form>
  
  <div class="quiz-status" id={`status-${quizId}`} style="display: none;">
    <div class="status-content">
      <h3>Previous Attempt</h3>
      <div class="previous-score" id={`prev-score-${quizId}`}></div>
      <div class="attempts-remaining" id={`attempts-${quizId}`}></div>
    </div>
  </div>
  
  <div class="quiz-results" id={`results-${quizId}`} style="display: none;">
    <div class="results-header">
      <h3>Results</h3>
      <div class="score-display" id={`score-${quizId}`}></div>
    </div>
    <div class="results-details" id={`details-${quizId}`}></div>
    <button class="retake-button" id={`retake-${quizId}`} style="display: none;">ðŸ”„ REQUEST RE-IGNITION (Attempt 2/2)</button>
  </div>
  
  <div class="quiz-locked" id={`locked-${quizId}`} style="display: none;">
    <div class="locked-content">
      <h3>ðŸ”’ MISSION LOCKED</h3>
      <p>Maximum attempts reached. Your highest score has been recorded.</p>
      <div class="final-score" id={`final-score-${quizId}`}></div>
    </div>
  </div>
</div>

<script define:vars={{ quizId, questions, passingScore, effectiveMaxAttempts }}>
  (async () => {
    const form = document.getElementById(`quiz-form-${quizId}`);
    const resultsDiv = document.getElementById(`results-${quizId}`);
    const scoreDiv = document.getElementById(`score-${quizId}`);
    const detailsDiv = document.getElementById(`details-${quizId}`);
    const retakeBtn = document.getElementById(`retake-${quizId}`);
    const statusDiv = document.getElementById(`status-${quizId}`);
    const lockedDiv = document.getElementById(`locked-${quizId}`);
    const maxAttempts = effectiveMaxAttempts;
    const unlimitedAttempts = maxAttempts >= 999999;
    const submitBtn = document.getElementById(`submit-${quizId}`);
    
    let currentAttempts = 0;
    let bestScore = 0;
    
    // Wait for auth
    const waitForAuth = async () => {
      let attempts = 0;
      while (!window.__auth) {
        if (attempts++ > 100) return false;
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      return true;
    };
    
    // Load previous progress on page load
    const loadProgress = async () => {
      const authAvailable = await waitForAuth();
      if (!authAvailable) return;
      
      const authed = await window.__auth.isAuthed();
      if (!authed) return;
      
      try {
        const token = await window.__auth.getAccessToken();
        const response = await fetch(`/api/progress-get?quizId=${quizId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          currentAttempts = data.attempts || 0;
          bestScore = data.bestScore || 0;
          
          // If already attempted, show status
          if (currentAttempts > 0) {
            statusDiv.style.display = 'block';
            document.getElementById(`prev-score-${quizId}`).innerHTML = `
              <span class="score-label">Best Score:</span> 
              <span class="score-value ${bestScore >= passingScore ? 'passed' : 'failed'}">${bestScore}%</span>
            `;
            document.getElementById(`attempts-${quizId}`).innerHTML = 
              unlimitedAttempts
                ? 'âœ… Unlimited attempts allowed'
                : (currentAttempts >= maxAttempts 
                    ? 'ðŸ”’ No attempts remaining' 
                    : `âœ… ${maxAttempts - currentAttempts} attempt(s) remaining`);
          }
          
          // If max attempts reached, lock the quiz (skip if unlimited)
          if (!unlimitedAttempts && currentAttempts >= maxAttempts) {
            form.style.display = 'none';
            lockedDiv.style.display = 'block';
            document.getElementById(`final-score-${quizId}`).innerHTML = `
              <span class="final-score-label">Final Score:</span>
              <span class="final-score-value ${bestScore >= passingScore ? 'passed' : 'failed'}">${bestScore}%</span>
            `;
          }
          
          // Load draft answers if any
          if (data.draft) {
            Object.entries(data.draft).forEach(([qId, answer]) => {
              if (Array.isArray(answer)) {
                answer.forEach(val => {
                  const input = form.querySelector(`input[name="q-${qId}"][value="${val}"]`);
                  if (input) input.checked = true;
                });
              } else {
                const input = form.querySelector(`input[name="q-${qId}"][value="${answer}"]`);
                if (input) input.checked = true;
              }
            });
          }
        }
      } catch (err) {
        console.error('[Quiz] Failed to load progress:', err);
      }
    };
    
    // Save draft answers on change
    const saveDraft = async (answers) => {
      const authAvailable = await waitForAuth();
      if (!authAvailable) return;
      
      const authed = await window.__auth.isAuthed();
      if (!authed) return;
      
      try {
        const token = await window.__auth.getAccessToken();
        await fetch('/api/progress-update', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            type: 'quiz-draft',
            id: quizId,
            draft: answers
          }),
        });
      } catch (err) {
        console.error('[Quiz] Draft save failed:', err);
      }
    };
    
    // Save draft on any input change
    form.addEventListener('change', () => {
      const formData = new FormData(form);
      const answers = {};
      questions.forEach((q) => {
        if (q.type === 'checkbox') {
          answers[q.id] = formData.getAll(`q-${q.id}`);
        } else {
          answers[q.id] = formData.get(`q-${q.id}`);
        }
      });
      saveDraft(answers);
    });
    
    // Load progress on init
    loadProgress();
    
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      // Check if attempts exhausted (skip if unlimited)
      if (!unlimitedAttempts && currentAttempts >= maxAttempts) {
        alert('Maximum attempts reached. You cannot retake this quiz.');
        return;
      }
      
      const formData = new FormData(form);
      const answers = {};
      
      // Collect answers
      questions.forEach((q) => {
        if (q.type === 'checkbox') {
          answers[q.id] = formData.getAll(`q-${q.id}`);
        } else {
          answers[q.id] = formData.get(`q-${q.id}`);
        }
      });
      
      // Grade quiz
      let correct = 0;
      const details = [];
      
      questions.forEach((q, index) => {
        const userAnswer = answers[q.id];
        let isCorrect = false;
        
        if (q.type === 'checkbox') {
          const correctAnswers = Array.isArray(q.correctAnswer) ? q.correctAnswer : [q.correctAnswer];
          const userAnswers = Array.isArray(userAnswer) ? userAnswer : [userAnswer];
          isCorrect = correctAnswers.length === userAnswers.length && 
                      correctAnswers.every(a => userAnswers.includes(a));
        } else {
          isCorrect = userAnswer === q.correctAnswer;
        }
        
        if (isCorrect) correct++;
        
        details.push({
          questionNumber: index + 1,
          question: q.question,
          userAnswer,
          correctAnswer: q.correctAnswer,
          isCorrect,
          explanation: q.explanation
        });
      });
      
      const score = Math.round((correct / questions.length) * 100);
      const passed = score >= passingScore;
      
      // Display results
      form.style.display = 'none';
      resultsDiv.style.display = 'block';
      
      scoreDiv.innerHTML = `
        <div class="score ${passed ? 'passed' : 'failed'}">
          <div class="score-number">${score}%</div>
          <div class="score-label">${correct} / ${questions.length} correct</div>
          <div class="pass-status">${passed ? 'âœ“ Passed' : 'âœ— Did not pass'}</div>
        </div>
      `;
      
      detailsDiv.innerHTML = details.map(d => `
        <div class="result-item ${d.isCorrect ? 'correct' : 'incorrect'}">
          <div class="result-header">
            <span class="result-icon">${d.isCorrect ? 'âœ“' : 'âœ—'}</span>
            <strong>Question ${d.questionNumber}</strong>
          </div>
          <p class="result-question">${d.question}</p>
          <p class="result-answer">
            <strong>Your answer:</strong> ${Array.isArray(d.userAnswer) ? d.userAnswer.join(', ') : d.userAnswer || '(no answer)'}
          </p>
          ${!d.isCorrect ? `
            <p class="result-correct">
              <strong>Correct answer:</strong> ${Array.isArray(d.correctAnswer) ? d.correctAnswer.join(', ') : d.correctAnswer}
            </p>
          ` : ''}
          ${d.explanation ? `<p class="result-explanation">${d.explanation}</p>` : ''}
        </div>
      `).join('');
      
      // Save result
      const result = {
        quizId,
        score,
        passed,
        correct,
        total: questions.length,
        answers,
        timestamp: new Date().toISOString()
      };
      
      // Save to localStorage
      localStorage.setItem(`quiz-result-${quizId}`, JSON.stringify(result));
      
      // Save to Upstash if logged in
      const authAvailable = await waitForAuth();
      if (authAvailable) {
        const authed = await window.__auth.isAuthed();
        if (authed) {
          try {
            const token = await window.__auth.getAccessToken();
            await fetch('/api/completion-update', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                type: 'quiz',
                id: quizId,
                score,
                passed,
                answers
              }),
            });
            
            // Also update progress store for gatekeeper checks
            // Uses pageId format so score is stored correctly
            await fetch('/api/progress-update', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                pageId: quizId,
                status: passed ? 'passed' : 'attempted',
                score
              }),
            });
            
            // Increment attempt count locally
            currentAttempts++;
            
            // Update best score if this one is higher
            if (score > bestScore) {
              bestScore = score;
            }
            
            // If passed a gatekeeper quiz, show success message with link to proceed
            if (passed && (quizId === 'week-01-required-quiz' || quizId === 'week-01-syllabus-quiz')) {
              const successMsg = document.createElement('div');
              successMsg.className = 'gatekeeper-success';
              successMsg.innerHTML = `
                <h3>ðŸŽ‰ Content Unlocked!</h3>
                <p>You have passed the Syllabus Assessment. All course content is now available.</p>
                <a href="/week-01/lesson-1/" class="proceed-btn">Proceed to Week 1 Lesson â†’</a>
              `;
              resultsDiv.appendChild(successMsg);
            }
            
          } catch (err) {
            console.error('[Quiz] Save to cloud failed:', err);
          }
        }
      }
      
      // Show retake button only if attempts remain and didn't pass (or unlimited attempts)
      if ((unlimitedAttempts || currentAttempts < maxAttempts) && !passed) {
        retakeBtn.style.display = 'block';
        retakeBtn.textContent = unlimitedAttempts 
          ? `ðŸ”„ TRY AGAIN` 
          : `ðŸ”„ REQUEST RE-IGNITION (Attempt ${currentAttempts + 1}/${maxAttempts})`;
      } else if (!unlimitedAttempts && currentAttempts >= maxAttempts) {
        retakeBtn.style.display = 'none';
        // Show locked message
        const lockedMsg = document.createElement('div');
        lockedMsg.className = 'attempts-exhausted';
        lockedMsg.innerHTML = 'ðŸ”’ Maximum attempts reached. Your best score has been recorded.';
        resultsDiv.appendChild(lockedMsg);
      }
    });
    
    retakeBtn.addEventListener('click', () => {
      if (!unlimitedAttempts && currentAttempts >= maxAttempts) {
        alert('Maximum attempts reached. You cannot retake this quiz.');
        return;
      }
      form.reset();
      form.style.display = 'block';
      resultsDiv.style.display = 'none';
      retakeBtn.style.display = 'none';
      statusDiv.style.display = 'none';
    });
  })();
</script>

<style>
  .quiz-container {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 24px;
    margin: 24px 0;
  }
  
  .quiz-header h2 {
    margin: 0 0 8px 0;
    color: var(--text);
  }
  
  .quiz-info {
    color: var(--text-muted);
    margin: 0 0 24px 0;
  }
  
  .quiz-form {
    display: flex;
    flex-direction: column;
    gap: 24px;
  }
  
  .quiz-question {
    background: var(--panel2);
    border-radius: 6px;
    padding: 16px;
  }
  
  .question-number {
    color: var(--accent);
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 8px;
  }
  
  .question-text {
    color: var(--text);
    margin: 0 0 16px 0;
    font-size: 16px;
    line-height: 1.5;
  }
  
  .options {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  
  .option-label {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    color: var(--text);
  }
  
  .option-label:hover {
    border-color: var(--accent);
    background: var(--navitem-hover);
  }
  
  .option-label input {
    cursor: pointer;
  }
  
  .submit-button, .retake-button {
    background: var(--accent);
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 6px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  .submit-button:hover, .retake-button:hover {
    background: var(--accent-hover);
  }
  
  .quiz-results {
    text-align: left;
  }
  
  .results-header {
    margin-bottom: 24px;
  }
  
  .results-header h3 {
    margin: 0 0 16px 0;
    color: var(--text);
  }
  
  .score {
    background: var(--panel2);
    padding: 20px;
    border-radius: 8px;
    text-align: center;
  }
  
  .score-number {
    font-size: 48px;
    font-weight: 700;
    margin-bottom: 8px;
  }
  
  .score.passed {
    border: 2px solid #10b981;
  }
  
  .score.passed .score-number {
    color: #10b981;
  }
  
  .score.failed {
    border: 2px solid #ef4444;
  }
  
  .score.failed .score-number {
    color: #ef4444;
  }
  
  .score-label {
    color: var(--text-muted);
    margin-bottom: 8px;
  }
  
  .pass-status {
    font-weight: 600;
    font-size: 18px;
    margin-top: 8px;
  }
  
  .score.passed .pass-status {
    color: #10b981;
  }
  
  .score.failed .pass-status {
    color: #ef4444;
  }
  
  .results-details {
    display: flex;
    flex-direction: column;
    gap: 16px;
    margin-bottom: 24px;
  }
  
  .result-item {
    background: var(--panel2);
    border-radius: 6px;
    padding: 16px;
    border-left: 4px solid var(--border);
  }
  
  .result-item.correct {
    border-left-color: #10b981;
  }
  
  .result-item.incorrect {
    border-left-color: #ef4444;
  }
  
  .result-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  
  .result-icon {
    font-size: 18px;
  }
  
  .result-item.correct .result-icon {
    color: #10b981;
  }
  
  .result-item.incorrect .result-icon {
    color: #ef4444;
  }
  
  .result-question {
    color: var(--text);
    margin: 8px 0;
  }
  
  .result-answer, .result-correct {
    color: var(--text-muted);
    font-size: 14px;
    margin: 4px 0;
  }
  
  .result-explanation {
    color: var(--text);
    font-size: 14px;
    margin-top: 8px;
    padding: 8px;
    background: var(--panel);
    border-radius: 4px;
  }
  
  .retake-button {
    width: 100%;
  }
  
  /* Status and locked states */
  .quiz-status {
    background: var(--panel2);
    border: 1px solid var(--accent);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 20px;
  }
  
  .quiz-status h3 {
    margin: 0 0 12px 0;
    color: var(--accent);
    font-size: 16px;
  }
  
  .previous-score {
    margin-bottom: 8px;
  }
  
  .score-label {
    color: var(--text-muted);
  }
  
  .score-value {
    font-weight: 700;
    font-size: 18px;
    margin-left: 8px;
  }
  
  .score-value.passed {
    color: #10b981;
  }
  
  .score-value.failed {
    color: #ef4444;
  }
  
  .attempts-remaining {
    color: var(--text-muted);
    font-size: 14px;
  }
  
  .quiz-locked {
    background: var(--panel2);
    border: 2px solid #ef4444;
    border-radius: 8px;
    padding: 24px;
    text-align: center;
  }
  
  .quiz-locked h3 {
    margin: 0 0 12px 0;
    color: #ef4444;
  }
  
  .quiz-locked p {
    color: var(--text-muted);
    margin-bottom: 16px;
  }
  
  .final-score-label {
    color: var(--text-muted);
  }
  
  .final-score-value {
    font-weight: 700;
    font-size: 24px;
    margin-left: 8px;
  }
  
  .final-score-value.passed {
    color: #10b981;
  }
  
  .final-score-value.failed {
    color: #ef4444;
  }
  
  .attempts-exhausted {
    margin-top: 16px;
    padding: 12px;
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid #ef4444;
    border-radius: 6px;
    color: #ef4444;
    text-align: center;
    font-size: 14px;
  }
  
  .gatekeeper-success {
    margin-top: 24px;
    padding: 20px;
    background: rgba(16, 185, 129, 0.1);
    border: 2px solid #10b981;
    border-radius: 8px;
    text-align: center;
  }
  
  .gatekeeper-success h3 {
    margin: 0 0 12px 0;
    color: #10b981;
    font-size: 20px;
  }
  
  .gatekeeper-success p {
    margin: 0 0 16px 0;
    color: var(--text);
  }
  
  .proceed-btn {
    display: inline-block;
    padding: 12px 24px;
    background: #10b981;
    color: white;
    text-decoration: none;
    border-radius: 6px;
    font-weight: 600;
    transition: background 0.2s;
  }
  
  .proceed-btn:hover {
    background: #059669;
    text-decoration: none;
  }
</style>
